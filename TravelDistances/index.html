<!DOCTYPE html>
<HTML>

	<HEAD>
		<META charset="utf-8">
		<META name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="styles.css">
		<script src="three.min.js"></script>
		<script src="Detector.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="OBJLoader.js"></script>
		<script src="MTLLoader.js"></script>
		<script src="LoadModel.js"></script>
		<script src="LoadModel2.js"></script>
		<script src="LoadLines.js"></script>
		 <!-- <style> -->
			 <!-- body { -->
				 <!-- overflow: hidden;  -->
				 <!-- margin: 0;  -->
				 <!-- padding: 0;  -->
				 <!-- background: hsl(0, 0%, 10%);  -->
			 <!-- }  -->
		<!-- </style>  -->
	
	</HEAD>
	
	
	<BODY>
		<div id="container"></div>
		<script>
		
		
			//Setup:
			
			if (!Detector.webgl)
			{
				Detector.addGetWebGLMessage();
			}
			
			// Set the scene size.
			const WIDTH = window.innerWidth;
			const HEIGHT = window.innerHeight;

			// Set some camera attributes.
			const VIEW_ANGLE = 45;
			const ASPECT = WIDTH / HEIGHT;
			const NEAR = 0.1;
			const FAR = 10000;

			// Get the DOM element to attach to
			const container =
				document.querySelector('#container');

			// Create a WebGL renderer, camera
			// and a scene
			const renderer = new THREE.WebGLRenderer();
			const camera =
				new THREE.PerspectiveCamera(
					VIEW_ANGLE,
					ASPECT,
					NEAR,
					FAR
				);
			////////////////////////////////
			// Set initial camera position//
			////////////////////////////////
			//on chrome navigate to the desired view; ctrl+shift+i > execute on console: camera.getWorld.Quaternion() and camera.getWorldPosition()to get both values
			//define those values here

			camera.position.x = -228.522;
			camera.position.y = 1439.500;
			camera.position.z = 44.601;
			
			camera.Quaternion = new THREE.Quaternion(-0.107129,0.6989448,0.698944,-0.1071291);
			

	


			const scene = new THREE.Scene();

			// Add the camera to the scene.
			scene.add(camera);
			
			// Add ambient lighting
			const ambient = 0.5;
			scene.add(new THREE.AmbientLight(0xffffff, ambient));

			// Start the renderer.
			renderer.setSize(WIDTH, HEIGHT);
			renderer.setClearColor( 0xffffff, 1);

			// Attach the renderer-supplied
			// DOM element.
			container.appendChild(renderer.domElement);

			// Orbit controls:
			const controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.25;
			controls.enableZoom = true;
			
			// Set up the sphere vars
			const RADIUS = 50;
			const SEGMENTS = 16;
			const RINGS = 16;

						
			// create the sphere's material
			const sphereMaterial =
			  new THREE.MeshLambertMaterial(
				{
				  color: 0x0000CC,
				  side: THREE.DoubleSide
				});
			
			// Create a new mesh with
			// sphere geometry - we will cover
			// the sphereMaterial next!
			const sphere = new THREE.Mesh(

			  new THREE.SphereGeometry(
				RADIUS,
				SEGMENTS,
				RINGS),

			  sphereMaterial);

			// Move the Sphere back in Z so we
			// can see it.
			//sphere.position.z = -300;

			// Finally, add the sphere to the scene.
			//scene.add(sphere);

			// Custom geometry:
			var geom = new THREE.Geometry();
			var geom2 = new THREE.Geometry();
			
			LoadGeom();
			LoadGeom2();
			
			var lineMat = new THREE.LineBasicMaterial( { color: 0x000000 } );
			LoadLine();
			//var curves = new THREE.Geometry();
			
			//curves.vertices.push(new THREE.Vector3(-10,0,0));
			//curves.vertices.push(new THREE.Vector3(0,10,0));
			//curves.vertices.push(new THREE.Vector3(10,0,0));
			
			//var line = new THREE.Line(curves,lineMat);
			//scene.add(line);
			
			
			//geom.vertices.push(new THREE.Vector3(0,0,0));
			//geom.vertices.push(new THREE.Vector3(0,100,0));
			//geom.vertices.push(new THREE.Vector3(100,0,0));
			//geom.vertices.push(new THREE.Vector3(100,100,0));
			
			//Needed to mirror the 3dmodel (The mesh needs this operation match the lines)
			geom.applyMatrix(new THREE.Matrix4().makeScale(-1,1,1));
			geom2.applyMatrix(new THREE.Matrix4().makeScale(-1,1,1));


			// Set vertex colours:
			//geom.faces[0].vertexColors[0] = new THREE.Color("rgb(255,0,0)");
			//geom.faces[0].vertexColors[1] = new THREE.Color("rgb(0,255,0)");
			//geom.faces[0].vertexColors[2] = new THREE.Color("rgb(0,0,255)");
			//geom.faces[0].vertexColors[3] = new THREE.Color("rgb(0,0,255)");
			
			

			geom.computeFaceNormals();
			geom2.computeFaceNormals();
			
			var material = new THREE.MeshLambertMaterial( {  wireframe: false, flatShading: true, vertexColors:  THREE.VertexColors , side : THREE.DoubleSide} );

			var mObj = new THREE.Mesh(geom, material);
			var mObj2 = new THREE.Mesh(geom2,material);
			
			scene.add(mObj);
			
			// create a point light
			const pointLight =
			  new THREE.AmbientLight(0xffffff);
			  
			pointLight.intensity = 0.25;

			// set its position
			//pointLight.position.x = 10;
			//pointLight.position.y = 50;
			//pointLight.position.z = 130;

			// add to the scene
			scene.add(pointLight);
			
			// Draw!
			renderer.render(scene, camera);
		
			function update () {
			  // Draw!
			  renderer.render(scene, camera);
			  controls.update();
			  // Schedule the next frame.
			  requestAnimationFrame(update);
			}
			
			//switch between multiple layers
			var i=1; // controller var
			
			function switch_layer(){
				if(i==0){
					scene.remove(mObj2);
					scene.add(mObj);
					i=1;
				}else{
					scene.remove(mObj);
					scene.add(mObj2);
					i=0;
				}
			}
			
			
			

			// Schedule the first frame.
			requestAnimationFrame(update);
		
		</script>
	<div id='menu'>
	<input type="button" value="Switch Target" onclick="switch_layer();">
	
	</div>
	
	</BODY>

</HTML>